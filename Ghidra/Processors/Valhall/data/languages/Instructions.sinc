
define endian=little;
define alignment=8;

define space ram type=ram_space size=8 default;
define space register type=register_space size=4;

define token opword (64)
        src1         = (0,7)
        src2         = (8,15)
        src3         = (16,23)
        src4         = (24,31)

        src1r        = (0,5)
        src1u        = (0,5)
        src1i        = (0,4)
        src1ts       = (0,2)
        src1id       = (0,4)
        src1t        = (6,7)
        src2r        = (8,13)
        src2u        = (8,13)
        src2i        = (8,12)
        src2ts       = (8,10)
        src2id       = (8,12)
        src2t        = (14,15)
        src3r        = (16,21)
        src3u        = (16,21)
        src3i        = (16,20)
        src3ts       = (16,18)
        src3id       = (16,20)
        src3t        = (22,23)
        src4r        = (24,29)
        src4u        = (24,29)
        src4i        = (24,28)
        src4ts       = (24,26)
        src4id       = (24,28)
        src4t        = (30,31)

        absneg1      = (38,39)
        absneg2      = (36,37)
        absneg3      = (34,35)
        absneg4      = (32,33)

        D1           = (40,45)
        DM           = (46,47)

        second2      = (16,19)

        clamp        = (32,33)

        ofs          = (8,23) signed
        constant     = (8,39)
        sr_count     = (33,35)
        load_lane    = (36,38)
        unsigned_skip = (39,39)
        op           = (48,56)
        imm_mode     = (57,58)
        action       = (59,61)
        do_action    = (62,62)
;

define register offset=0x00 size=4 [
        r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
        r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31
        r32 r33 r34 r35 r36 r37 r38 r39 r40 r41 r42 r43 r44 r45 r46 r47
        r48 r49 r50 r51 r52 r53 r54 r55 r56 r57 r58 r59 r60 r61 r62 r63
];

define register offset=0x100 size=4 [
        u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15
        u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31
        u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47
        u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63
];

# TODO: Use program_counter
define register offset=0x200 size=8 [
        PC SP
];

define register offset=0x300 size=4 [
        tls_ptr tls_ptr_hi wls_ptr wls_ptr_hi
        lane_id core_id program_counter
];

attach variables [ src1r src2r src3r src4r D1 ] [
        r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
        r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31
        r32 r33 r34 r35 r36 r37 r38 r39 r40 r41 r42 r43 r44 r45 r46 r47
        r48 r49 r50 r51 r52 r53 r54 r55 r56 r57 r58 r59 r60 r61 r62 r63
];

attach variables [ src1u src2u src3u src4u ] [
        u0 u1 u2 u3 u4 u5 u6 u7 u8 u9 u10 u11 u12 u13 u14 u15
        u16 u17 u18 u19 u20 u21 u22 u23 u24 u25 u26 u27 u28 u29 u30 u31
        u32 u33 u34 u35 u36 u37 u38 u39 u40 u41 u42 u43 u44 u45 u46 u47
        u48 u49 u50 u51 u52 u53 u54 u55 u56 u57 u58 u59 u60 u61 u62 u63
];

attach values [ src1i src2i src3i src4i ] [
        0x0 0xffffffff 0x7fffffff 0xfafcfdfe 0x1000000 0x80002000
        0x70605030 0xc0b0a090 0x3020100 0x7060504 0xb0a0908 0xf0e0d0c
        0x13121110 0x17161514 0x1b1a1918 0x1f1e1d1c 0x3f800000
        0x3dcccccd 0x3ea2f983 0x3f317218 0x40490fdb 0x0 0x477fff00
        0x5c005bf8 0x2e660000 0x34000000 0x38000000 0x3c000000
        0x40000000 0x44000000 0x48000000 0x42480000
];

attach variables [ src1ts src2ts src3ts src4ts ] [
        _ _ tls_ptr tls_ptr_hi _ _ wls_ptr wls_ptr_hi
];

attach variables [ src1id src2id src3id src4id ] [
        _ _ lane_id _ _ _ core_id _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
        _ _ _ _ _ program_counter _
];

#S$: src$r is src$r & src$t=0 { export src$r; }
#S$: "`"^src$r is src$r & src$t=1 { export src$r; }
#S$: src$u is src$u & src$t=2 { export src$u; }
#S$: src$i is src$i & src$t=3 & imm_mode=0 { export src$i; }
#S$: src$ts is src$ts & src$t=3 & imm_mode=$ { export src$ts; }
#S$: src$id is src$id & src$t=3 & imm_mode=3 { export src$id; }

S1: src1r is src1r & src1t=0 { export src1r; }
S1: "`"^src1r is src1r & src1t=1 { export src1r; }
S1: src1u is src1u & src1t=2 { export src1u; }
S1: src1i is src1i & src1t=3 & imm_mode=0 { export src1i; }
S1: src1ts is src1ts & src1t=3 & imm_mode=1 { export src1ts; }
S1: src1id is src1id & src1t=3 & imm_mode=3 { export src1id; }

S2: src2r is src2r & src2t=0 { export src2r; }
S2: "`"^src2r is src2r & src2t=1 { export src2r; }
S2: src2u is src2u & src2t=2 { export src2u; }
S2: src2i is src2i & src2t=3 & imm_mode=0 { export src2i; }
S2: src2ts is src2ts & src2t=3 & imm_mode=2 { export src2ts; }
S2: src2id is src2id & src2t=3 & imm_mode=3 { export src2id; }

#AN$: S$ is S$ & absneg$=0 { export S$; }
#AN$: S$^".neg" is S$ & absneg$=1 { t:4 = 0:4 f- S$; export t; }
#AN$: S$^".abs" is S$ & absneg$=2 { t:4 = abs(S$); export t; }
#AN$: S$^".neg.abs" is S$ & absneg$=3 { t:4 = 0:4 f- abs(S$); export t; }

AN1: S1 is S1 & absneg1=0 { export S1; }
AN1: S1^".neg" is S1 & absneg1=1 { t:4 = 0:4 f- S1; export t; }
AN1: S1^".abs" is S1 & absneg1=2 { t:4 = abs(S1); export t; }
AN1: S1^".neg.abs" is S1 & absneg1=3 { t:4 = 0:4 f- abs(S1); export t; }

AN2: S2 is S2 & absneg2=0 { export S2; }
AN2: S2^".neg" is S2 & absneg2=1 { t:4 = 0:4 f- S2; export t; }
AN2: S2^".abs" is S2 & absneg2=2 { t:4 = abs(S2); export t; }
AN2: S2^".neg.abs" is S2 & absneg2=3 { t:4 = 0:4 f- abs(S2); export t; }

macro Store(reg, mask, val) {
      maskv = (mask & 1) * 0xffff + (mask & 2) * 0x7fff8000;
      reg = (val & maskv) | (reg & ~maskv);
}

macro StoreClamp(reg, mask, clamp, val) {
      # if bit 1 is set, clamp to -1
      clamp_m1 = zext(val f> 0xbf800000:4) * val + zext(val f<= 0xbf800000) * 0xbf800000:4;
      val = zext((clamp & 1:1) != 0:1) * clamp_m1 + zext((clamp & 1:1) == 0:1) * val;

      # if bit 2 is set, clamp to 0
      clamp_0 = zext(val f> 0:4) * val + zext(val f<= 0) * 0:4;
      val = zext((clamp & 2:1) != 0:1) * clamp_0 + zext((clamp & 2:1) == 0:1) * val;

      # if bit 3 is set, clamp to 1
      clamp_1 = zext(val f> 0x3f800000:4) * 0x3f800000:4 + zext(val f<= 0x3f800000:4) * val;
      val = zext((clamp & 4:1) != 0:1) * clamp_1 + zext((clamp & 4:1) == 0:1) * val;

      Store(reg, mask, val);
}

:MOV.i32 D1, S1 is op=0x91 & second2=0x0 & D1 & DM & S1 {
        Store(D1, DM, S1);
}

DC: "" is clamp=0 { export 0:1; }
DC: "clamp_0_inf" is clamp=1 { export 2:1; }
DC: "clamp_m1_1" is clamp=2 { export 5:1; }
DC: "clamp_0_1" is clamp=3 { export 6:1; }

:FADD.f32 D1 DC, AN1, AN2 is op=0xA4 & D1 & DC & DM & AN1 & AN2 {
        StoreClamp(D1, DM, DC, AN1 f+ AN2);
}
